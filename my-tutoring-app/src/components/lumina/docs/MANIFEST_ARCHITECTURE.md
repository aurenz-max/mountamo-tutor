# Manifest-First Architecture Guide

## Overview

The Manifest-First Architecture is a new approach to generating educational exhibits that separates **planning** from **execution**. Instead of generating content in a single monolithic call, the system works in phases:

1. **Blueprint Phase**: Generate a manifest describing what components to use
2. **Build Phase**: Generate content for each component in parallel
3. **Assembly Phase**: Combine all components into the final exhibit

## Why Manifest-First?

### Benefits
- **Transparency**: See the exhibit structure before generating expensive content
- **Scalability**: Generate components in parallel for faster performance
- **Flexibility**: Easy to add new component types without changing core logic
- **Modularity**: Each component is self-contained and testable
- **Control**: Modify the manifest before building for fine-tuned customization

### Comparison with Legacy Flow

| Aspect | Legacy Flow | Manifest-First |
|--------|-------------|----------------|
| **Approach** | Monolithic single generation | Three-phase pipeline |
| **Visibility** | Black box until complete | Preview manifest first |
| **Performance** | Sequential component generation | Parallel content generation |
| **Flexibility** | Hardcoded exhibit structure | Dynamic component composition |
| **Extensibility** | Requires schema changes | Just add to catalog |

## Architecture Components

### 1. Universal Component Catalog

Located in `geminiService.ts`, the `UNIVERSAL_CATALOG` defines all available building blocks:

```typescript
export const UNIVERSAL_CATALOG: ComponentDefinition[] = [
  {
    id: 'curator-brief',
    description: 'Introduction, learning objectives, and hook',
    constraints: 'Must be first component'
  },
  {
    id: 'concept-card-grid',
    description: 'A set of 3-4 key terms/concepts with visuals'
  },
  // ... more components
];
```

**Available Components:**
- `curator-brief` - Introduction and learning objectives
- `concept-card-grid` - Key concept cards (typically 3-4)
- `feature-exhibit` - Deep-dive editorial section
- `comparison-panel` - Side-by-side A vs B analysis
- `generative-table` - Structured data tables
- `sentence-analyzer` - Linguistic/grammar breakdown
- `formula-card` - Mathematical formulas (LaTeX)
- `math-visual` - Interactive math primitives (blocks, circles, etc.)
- `custom-visual` - Bespoke HTML/SVG simulations
- `knowledge-check` - Multiple choice quiz

### 2. Manifest Structure

The manifest is a JSON blueprint generated by Gemini:

```typescript
interface ExhibitManifest {
  topic: string;           // "Photosynthesis"
  gradeLevel: string;      // "middle-school"
  themeColor: string;      // "#10b981" (hex color)
  layout: ManifestItem[];  // Ordered array of components
}

interface ManifestItem {
  componentId: ComponentId;  // From UNIVERSAL_CATALOG
  instanceId: string;        // Unique ID like "brief-1" or "math-visual-counting"
  title: string;             // Display heading
  intent: string;            // Detailed generation instructions
  config?: any;              // Optional component-specific config
}
```

**Example Manifest:**

```json
{
  "topic": "Addition for Kindergarten",
  "gradeLevel": "kindergarten",
  "themeColor": "#3b82f6",
  "layout": [
    {
      "componentId": "curator-brief",
      "instanceId": "brief-1",
      "title": "Welcome to Addition!",
      "intent": "Create a warm introduction about adding numbers together. Learning objectives: 1) Understand addition, 2) Count objects to add them, 3) Use the plus symbol"
    },
    {
      "componentId": "math-visual",
      "instanceId": "math-counting-1",
      "title": "Let's Count Together",
      "intent": "Show addition using a number line from 0-10. Highlight 2 + 3 = 5.",
      "config": { "visualType": "number-line" }
    },
    {
      "componentId": "knowledge-check",
      "instanceId": "quiz-1",
      "title": "Check Your Understanding",
      "intent": "Simple addition question: If you have 2 apples and get 1 more, how many total?"
    }
  ]
}
```

### 3. Component Content Generators

Each component type has a dedicated generator function in `geminiService.ts`:

- `generateCuratorBriefContent()` - Hook + learning objectives
- `generateConceptCardsContent()` - Array of concept cards
- `generateMathVisualContent()` - Math visualization data
- `generateCustomVisualContent()` - Custom HTML/SVG exhibits
- `generateComparisonContent()` - Comparative analysis
- `generateTableContent()` - Structured tables
- `generateFeatureExhibitContent()` - Deep-dive sections
- `generateKnowledgeCheckContent()` - Quiz questions
- `generateFormulaCardContent()` - Mathematical formulas
- `generateSentenceAnalyzerContent()` - Sentence diagrams

## Usage Guide

### Phase 1: Preview Manifest Only

Use this to see the exhibit blueprint before generating content:

```typescript
import { generateExhibitManifest } from './service/geminiService';

const manifest = await generateExhibitManifest('Photosynthesis', 'middle-school');
console.log(manifest);
// See what components will be used, in what order, with what intent
```

**UI Button:** "ðŸ“‹ Preview Manifest Only" (Purple button on home screen)

### Phase 2: Complete Build (Manifest â†’ Exhibit)

Use this for the full end-to-end generation:

```typescript
import { buildCompleteExhibitFromTopic } from './service/geminiService';

const exhibit = await buildCompleteExhibitFromTopic('Photosynthesis', 'middle-school');
setExhibitData(exhibit);
```

**UI Button:** "âœ¨ Build with Manifest-First" (Green button on home screen)

**Console Output Example:**
```
ðŸŽ¯ Starting complete exhibit build for: Photosynthesis
ðŸ“‹ Phase 1: Generating manifest...
âœ… Manifest generated with 6 components
ðŸŽ¨ Phase 2: Generating content for all components...
  âš™ï¸ [1/6] Generating: curator-brief (brief-1)
  âš™ï¸ [2/6] Generating: concept-card-grid (concepts-1)
  âš™ï¸ [3/6] Generating: custom-visual (diagram-chloroplast)
  âš™ï¸ [4/6] Generating: feature-exhibit (deep-dive-1)
  âš™ï¸ [5/6] Generating: generative-table (comparison-table)
  âš™ï¸ [6/6] Generating: knowledge-check (quiz-1)
  âœ… [1/6] Completed: curator-brief
  âœ… [2/6] Completed: concept-card-grid
  âœ… [3/6] Completed: custom-visual
  âœ… [4/6] Completed: feature-exhibit
  âœ… [5/6] Completed: generative-table
  âœ… [6/6] Completed: knowledge-check
âœ… Generated 6/6 components successfully
ðŸ—ï¸ Phase 3: Assembling exhibit...
ðŸŽ‰ Exhibit assembly complete!
```

### Legacy Flow (Still Available)

The original single-call generation is still available:

```typescript
import { generateExhibitContent } from './service/geminiService';

const exhibit = await generateExhibitContent('Photosynthesis', 'middle-school');
```

**UI Button:** Standard search submit (White arrow button)

## Adding New Component Types

To add a new component to the system:

### 1. Add to TypeScript Types

Edit `types.ts`:

```typescript
export type ComponentId =
  | 'curator-brief'
  | 'concept-card-grid'
  // ... existing components
  | 'your-new-component';  // Add here
```

### 2. Register in Universal Catalog

Edit `geminiService.ts`:

```typescript
export const UNIVERSAL_CATALOG: ComponentDefinition[] = [
  // ... existing components
  {
    id: 'your-new-component',
    description: 'What this component does and when to use it',
    constraints: 'Optional: any usage constraints'
  }
];
```

### 3. Create Content Generator

Add to `geminiService.ts`:

```typescript
const generateYourNewComponentContent = async (
  item: any,
  topic: string,
  gradeContext: string
) => {
  const schema: Schema = {
    // Define your JSON schema
  };

  const response = await ai.models.generateContent({
    model: "gemini-2.5-flash",
    contents: `Create content for: "${topic}"

    TARGET AUDIENCE: ${gradeContext}
    INTENT: ${item.intent}

    Generate appropriate content.`,
    config: {
      responseMimeType: "application/json",
      responseSchema: schema,
      temperature: 0.7,
    },
  });

  if (!response.text) throw new Error("No content generated");
  const data = JSON.parse(response.text);

  return {
    type: 'your-new-component',
    instanceId: item.instanceId,
    data
  };
};
```

### 4. Add to Component Dispatcher

In `generateComponentContent()`:

```typescript
switch (item.componentId) {
  // ... existing cases
  case 'your-new-component':
    return await generateYourNewComponentContent(item, topic, gradeLevelContext);
  // ...
}
```

### 5. Add to Exhibit Assembler

In `buildCompleteExhibitFromTopic()`:

```typescript
switch (component.type) {
  // ... existing cases
  case 'your-new-component':
    exhibit.yourNewComponent = component.data;
    break;
  // ...
}
```

### 6. Create React Component

Create `primitives/YourNewComponent.tsx`:

```typescript
export const YourNewComponent: React.FC<{ data: YourNewComponentData }> = ({ data }) => {
  return (
    <div>
      {/* Render your component */}
    </div>
  );
};
```

### 7. Add to App.tsx Rendering

```typescript
{exhibitData.yourNewComponent && (
  <YourNewComponent data={exhibitData.yourNewComponent} />
)}
```

## Best Practices

### Manifest Generation
- Keep intents **specific and detailed** - vague intents = poor content
- Use `config` for component-specific hints (e.g., `visualType`, `itemCount`)
- Follow the recommended structure: curator-brief first, knowledge-check last
- Choose 4-8 components total for optimal learning flow

### Content Generation
- Always validate `response.text` before parsing
- Use appropriate Gemini model for complexity (flash for simple, pro for complex)
- Handle errors gracefully - don't block entire exhibit if one component fails
- Add detailed schema descriptions for better AI understanding

### Performance
- Parallel generation in Phase 2 is critical for performance
- Consider adding progress callbacks for long-running builds
- Cache manifests if generating multiple exhibits with same structure

### Debugging
- Check browser console for detailed phase logs
- Manifest validation errors will show in Phase 1
- Component generation errors will show in Phase 2 (but won't block others)
- Assembly errors will show in Phase 3

## Future Enhancements

Potential improvements to the architecture:

1. **Manifest Editing UI**: Allow users to modify manifest before building
2. **Component Marketplace**: Share and reuse manifest templates
3. **Progressive Generation**: Stream components as they complete instead of waiting for all
4. **Caching Layer**: Cache common component content for faster regeneration
5. **A/B Testing**: Generate multiple manifests, let AI choose best
6. **User Preferences**: Remember which component combinations work best for topics
7. **Related Topics**: Auto-generate manifests as another component type

## Troubleshooting

### Manifest Generation Fails
- Check API key is valid
- Verify topic is clear and specific
- Check console for Gemini API errors

### Component Generation Fails
- Some components may fail while others succeed (graceful degradation)
- Check if `intent` field has sufficient detail
- Verify component `config` matches expected format

### Assembly Issues
- Check component `type` field matches expected values
- Verify exhibit structure matches ExhibitData interface
- Look for mismatched component IDs

## Related Files

- `geminiService.ts` - Core generation logic
- `types.ts` - TypeScript interfaces
- `App.tsx` - UI integration
- `components/ManifestViewer.tsx` - Manifest preview component
- `primitives/*` - Individual component renderers

---

**Last Updated**: January 2025
**Architecture Version**: 2.0 (Manifest-First)
